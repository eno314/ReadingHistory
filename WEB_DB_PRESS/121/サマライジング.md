# WEB+DB PRESS Vol.121 サマライジング

## 装丁よみ

- Ruby3
  - コミッター直伝
  - さらに速く！
  - 書きやすく！
  - 詳解
  - JITコンパイラ
  - 静的型解析
  - 並列プログラミング
- iOS14
  - 最前線
  - UIKit
  - SwiftUI
  - iPadOS
  - ウィジェット
- OKR
  - 運用指南
  - 個人と組織の目標がリンクする
  - 管理手法
- 実例で知る
  - オブジェクト指向
  - UIデザイン
- 新登場
  - Go1.16からのモジュール管理
  - Composer2によるPHPパッケージ管理

## 特集1 詳解Ruby3

- Ruby3.0の特徴
  - JIT(Just In Time)コンパイルによる性能向上
  - 並行 / 並列プログラミングのため新たな仕組み(`Fiber Scheduler`と`Reactor`)
  - 静的型解析(RBS)
- JITコンパイラ
  - 実行時ネイティブコード化による高速化
  - JITを有効にしても必ずしも速くなるとは限らない。`RubyVM::MJIT.pause`を利用して性能計測するといい。
- Ractor
  - スレッド安全の問題を気にせずに並行/並列プログラミングを容易に行える
  - Ruby3.0ではまだ実験的機能で、今後仕様が変わる可能性がある
- Fiber Scheduler
  - 軽量な並行プログラミングのため、FiberベースのスケジューラをRubyで記述できるようにする機能
- 静的型解析 : 「RBS(Ruby標準の型記述言語)」「TypeProf(RBS半自動生成ツール)」「Steep(型検査ツール)」
  - 目的 : 「バグの可能性を見つける」「ドキュメンテーション」「IDEの機能向上」
  - 古いRubyのバージョンと完全な互換性がある
  - TypeProfは、「型注釈を(ほぼ)書かなくても型解析のメリットを(ある程度)享受できる」ことを目指しているツール
  - Steepは、Rubyのコードに対して型注釈を書くことを前提とする保守的な設計で、TypeProfとは対照的なツール
- 3章 : 詳解RBS
  - 静的型解析を実現するための記述方法を理解するための章
- その他の新機能
  - パターンマッチの導入
  - キーワード引数の改善
  - 一行メソッド定義の追加
- Rubyのこれから

## 特集2 iOS14最前線

- Appleプラットフォームの現状
  - ハード・ソフト・サービスをすべてコントロールすることで、他にはない体験を作り出している
  - 5つのOSに最適化されたSDKが提供されている(macOS,iOS,iPadOS,watchOS,tvOS)
  - 個々のプラットフォームに最適化されたUIフレームワークが提供されていて、SwiftUIはすべてのプラットフォームをサポートしている
  - ウィジェットのためのWidgetKitフレームワークが最近できていて、これもSwiftUIはサポートしている
  - iPadOSは今はiOSとほぼ一緒だが、徐々にmacOSに近づいている
- 2章 : UIKitによるアプリ開発
- 3章 : SwiftUIによるアプリ開発
- 4章 : iPadOS/macOSへの最適化
- 5章 : ウィジェットの開発

## 特集3 OKR運用指南

- OKRを構成する要素
  - 目標(Object) : 「何を達成したいのか」の定性的な方針
  - 成果指標(KeyResult) : 「目標の達成にどれだけ近づいたか」の定量的な基準
  - 1つの目標に対して複数の成果指標を設定することができ、すべての成果指標を達成することでOを達成したことになる
  - 目標は「無理をしなければ実現できない挑戦的な目標(ムーンショット)」を立てる
  - 成果指標は「タスク消化の先になるビジネスの成長(アウトカム)」でなければならない
- 優れたOKRが持つ特徴
  - 大局的な視点と客観的指標を併せ持つ
  - シンク・ビックの精神
  - 特定の部署に限定せず、組織全体で実践される
  - 人事評価制度ではなく、セルフコントロールとして用いる
  - 業務を網羅せず、力を入れるべき分野に限定する
- OKRの威力
  - フォーカス : 成果指標をすべて達成すれば、必ず目標を達成するようにする -> 目標達成に必要のない成果指標は並べない
  - アラインメント : 目標を公開することで、水平方向のチームワークを促す
  - トラッキング : データに基づき、進捗を明確にする
  - ストレッチ : 高い目標のほうが高い結果を残すことができる。その代わり、失敗を許容する文化を作り上げる。
- 個人のOKRを設定する
  - 挑戦的な目標を立てて、自身が成長できるように仕向ける
- チームにOKRを導入する
  - メンバー内の整合性を保ち、設定と評価を繰り返す
- OKRの運用を改善する
  - 最適なコミュニケーション手法を確立するためのヒント
- OKRはFASTを満たすように目標を立てる
  - F : Frequently Discussed 継続的な議論
  - A : Ambitious 挑戦的
  - S : Specific 具体的
  - T : Trasnparent 透明性
- 注意すべき落とし穴
  - OKRがストレッチゴールであるという説明が欠いている
  - 「現状維持でよし」的なOKR
  - 意図的に実力を隠す
  - 目標の価値を低い
  - 目標に対する成果指標が不十分
  - 絞り込みが不十分

## マネージャーの心理

- 「マネジメントに失敗は許されない」という考えを捨て去る
  - すべてを完璧にすることはできない
  - 失敗があっても学びに変えて、改善していく
- マネージャーは現場の主役にはならならい
  - 手柄はメンバーに立てさせ、メンバーの成果を向上させ、成長を促す
  - 現場でコード書けなくてトレンドについていけなくなる恐怖が怖いなら、個人で学習したり、定期的にコードを書く仕組みを作る

## オブジェクト指向UIデザイン

- OOUI設計を取り入れたUI設計の流れ
  - 仮設の設定と検証
  - USM(UserStoryMapping)の作成
  - MVP(MinimumViableProduct)の策定
  - オブジェクトの抽出
  - ビューの設計
- 業務アプリケーションにはOOUIが向いている
- 先にオブジェクトを整理しておくと、UI以外にもメリットがある
  - 後回し可能な機能が見極められる
  - 核となるオブジェクトの特定により、DB設計が効率化されたり、プロダクトの本質も見えてくる

## Go 1.16からのGoモジュール

- go.modファイル
  - Goで作成されたアプリやライブラリが依存する外部ライブラリの一覧とバージョンをメタ情報として指定したもの
  - アプリのビルドに冪等性(誰がその操作を何度行っても、同じ結果になる)をもたらすためのファイル
- Go1.16から、それまでの自動でgo.modファイルを更新されることはなくなり、新たなライブラリを使う場合は明示的に指定する必要がある
  - 1.16から、do.modの状態管理を意識して開発を進める必要がある
  - 大抵は、`go mod tidy`を実行すれば良い

## DjangoでAPI開発

- Djangoを使ったWebAPIを作る場合は、`Django Rest framework(DRF)` を使うと良い
- この記事は、Djangoは知っているが、DRFは初めて、という人向けの記事
- シリアライザ
  - JSONデータのバリデーションやPythonデータとの相互変換を強力にサポートしてくれる
- APIビュー
  - 典型的なREST_APIであれば、ジェネリックAPIビューやビューセットを使うと高速に開発できる
  - APIの仕様が複雑になり、REST原則に従わないようにする場合は、シンプルなAPIビューを使うと良い
