# カイゼン・ジャーニー サマライジング

## 装丁読み

- 英題 : Microservices Patterns With examples in Java
- マイクロサービスのパターン
- 実践的なシステムのデザイン
- コード解説
- 解説が充実している
  - パターンによるシステム開発
  - 実装方法をJavaのサンプルコードで
- マイクロサービスの事案を成功させる
- 実践的ノウハウを集めている
- Chris Richardson
  - <https://twitter.com/crichardson>
  - <https://www.chrisrichardson.net/>
  - マイクロサービスのトレーニングとコンサルティングをやっている
  - [POJOs in Action](https://www.amazon.co.jp/Pojos-Action-Developing-Applications-Lightweight/dp/1932394583)という本も出している（日本語訳は無さそう）
    - SpringやHibernateなどのFWを使ってJavaEEのアプリを構築する方法を説明する本
  - [Microservices.io](https://microservices.io/)の作者

## はじめに

本書はマイクロサービス宣言ではなく、パターンのコレクションを中心として構成されている

パターン : 特定のコンテキストで発生する問題に対して繰り返し応用できるソリューション
パターンの良いところ : ソリューションの利点だけでなく欠点や問題点も明示されている
↓
パターンを知っていれば、より良い決定をすることができるようになる

## 監修者まえがき

マイクロサービスのゴールは「素早く、高頻度に、アプリを開発・リリース・メンテナンスすること」

サービスのサイズが小さくなるのはあくまで結果であり、ゴールじゃない。だから小さくすることを目的にしたり、格好から入るようなことは良くないよ。

本書は設計のノウハウを単純にリストアップしているわけではなく、レガシーなアプリをモダン化していくストーリーになっていて、その中でマイクロサービスに関する様々な知識を解説している。つまり、マイクロサービスの適用を疑似体験できる作りになっている。

## 本書について

本書の目的 : マイクロサービスアーキテクチャを使ったアプリケーション開発を成功させるための方法を学ぶ

マイクロサービスのメリットだけでなくデメリットも挙げ、どんなときにモノリシックにして、どんなときにマイクロサービスにするのかを学ぶことができる

## Chapter1

「モノリシック地獄からの脱出」

- モノリシックなアプリケーションがヤバくなる兆候と、マイクロサービスを取り入れてそこから抜け出す方法
  - モノリシックアーキテクチャ : アプリを単一のデプロイ単位として構成。単純なアプリ向け。
  - マイクロサービスアーキテクチャ : システムを個別にデプロイでき、専用のDBを持つサービスに分割する。大規模で複雑なアプリ向け。
- マイクロサービスアーキテクチャの基本的な特徴と、メリット・デメリット
  - 特徴 : システムを個別にデプロイでき、専用のDBを持つサービスに分割する。
  - 大規模で複雑なアプリの場合にメリットが多い。
  - 万能薬ではない。大きな欠点がいくつもある（適切な分割が難しい、複雑になる、等）
- システムをマイクロサービスアーキテクチャにするだけでは上手く行かない
  - 「マイクロサービス」+「DevOps」+「小規模で自主性・自律性を持つチーム」が組み合わさることで、同時並行で仕事を進められ、ソフトウェア開発・デリバリーが加速する
  - 人間の問題（感情）を考慮する必要もある
- マイクロサービスアーキテクチャのパターン言語と、それを使うべき理由
  - パターン言語 : マイクロサービスを設計・開発する際に役立つパターン集
  - 使うべき理由 : マイクロサービスを取り入れるかの判断や、採用した際の効果的な適用方法を判断するのに役立つ

## Chapter2

「サービスへの分割」

- ソフトウェアアーキテクチャが重要な理由
  - アプリのメンテナンス性、テスト容易性、デプロイ容易性、等の開発スピードに影響を与える
  - マイクロサービスは、メンテナンス性、テスト容易性、デプロイ容易性を高めてくれる
- アプリケーションをサービスに分解するためのパターンを紹介
  - 技術的な問題ではなく、ビジネス上の問題(業務やサブドメイン)に基づいて構成する。
  - `Decompose by business capability` : 業務に対応させてサービスを定義するパターン
  - `Decompose by subdomain` : DDDのサブドメインに対応するかたちでサービスを定義するパターン
- サービスに分解する過程でぶつかる障害を乗り越える方法
  - 障害 : 神クラス(込み入った依存関係を作り出していて分割しにくいクラス)
  - 方法 : DDDの境界づけられたコンテキストの概念を使って、データを解きほぐし、分割を容易にする。サービスごとに別々のドメインモデルを定義する。

## Chapter3

「マイクロサービスアーキテクチャで使われるプロセス間通信」

- マイクロサービスは分散型のアーキテクチャなので、プロセス間通信が大きな役割を果たす
- サービスのAPIの発展の管理が大切
  - 下位互換のある変更は簡単
  - そうじゃない場合はすべてのクライアントがアップグレードされるまで、新旧両方のバージョンをサポートする必要がある
- プロセス間通信は色んなパターンがあるが、`Remote procedure invocation`と`Asynchronous messaging`のどちらにするかは特に重要な選択基準
- `Remote procedure invocation` : クライアントがRESTのような同期的なプロトコルを使ってサービスを起動する
  - `Circuit breaker`を使って、一部のサービスが落ちていても、全体に波及しないような工夫が必要
  - クライドベースのマイクロサービスでは、各サービスのネットワークは動的に割り当てれるので、サービスディスカバリのメカニズムを組み込む必要がある
    - たいていはクライドのプラットフォームがそういう機能を用意してくれている。無い場合はこの章で紹介されているパターンを参考にする。
- `Asynchronous messaging` : クライアントが非同期メッセージングを使ってサービスを呼び出す
  - 可用性を高くできる
  - メッセージシステムの細部を抽象化するような設計にする
  - DBの更新とメッセージのPublishをAtomicにする（どちらか片方だけ実行されて矛盾がおきないようにする）のは、非同期メッセージングの1つの大きな課題
  - `Transactional outbox`は優れた解決方法のひとつ
    1. DBトランザクションの一部として、DBにまずメッセージを書き出す
    1. `Transaction log tailing` か `Polling publisher` を使って、DBからメッセージを読み取りPublishする

## Chapter4

「サーガによるトランザクションの管理」

- マイクロサービスにおいて、複数のサービスに分散されたデータのトランザクション管理は難しい。
- XA/2PCベースの分散トランザクションは最近のストレージやメッセージの仕組みでは使えないため、Sagaパターンを使う方が良いことが多い。
- `Saga`
  - 非同期メッセージでコーディネートされた一連のローカルトランザクションを使って、複数にサービスにまたがるデータ整合性を維持する
  - Sagaのコーディネート方法は「コレオグラフィ」と「オーケストレーション」の2つ
  - 単純なサーガ以外はオーケストレーションを使うのがオススメ
- コレオグラフィ
  - 概要 : Sagaの参加サービスに次のステップの判断を委ねる
  - メリット : 単純で疎結合
  - デメリット : 分かりにくい、サービス間の循環的な依存が起きやすい、特定のサービス間の密結合の危険もある
- オーケストレーション
  - 概要 : コーディネートロジックを一元管理して、Saga参加サービスにどの操作を実行するか指示するコマンドを送る
  - メリット : 依存関係が単純、各サービス間が疎結合、関心事の分離がしやすくビジネスロジックも単純化されやすい
  - デメリット : オーケストレータにビジネスロジックが過度に集中するリスク
- SagaはACIDトランザクションとは異なり、I（分離性）が無いので、平行実行されるビジネスロジックの設計が難しい
  - 対策
    - 影響を最初化するカウンターメジャーを使う
    - ロックを使う（デッドロックのリスクはある）

## Chapter5

「マイクロサービスアーキテクチャにおけるビジネスロジックの設計」

- マイクロサービスにおけるビジネスロジックの実装パターン
  - `Transaction script` : 単純なビジネスロジックに適している。手続き型。
  - `Domain model` : 複雑なビジネスロジックに適している。オブジェクト指向型。
- 複雑なビジネスロジックの場合は、複数のDDDの`Aggregate`で構成することを推奨
  - 特徴
    - ドメインモデルのモジュール化
    - サービス境界を超えたオブジェクト参照の禁止
    - 個々のACIDトランザクションをひとつのサービス内で完結
  - Aggregateが作成・更新されたときは、`Domain event`をPublishするようにする
    - このイベントは様々な用途に使われる(Sagaを実装、複製されたデータ更新、ユーザーや他のアプリに通知、等)

## Chapter6

「イベントソーシングを使ったビジネスロジックの開発」

- `Event sourcing`
  - 個々のEventはAggregateの作成か状態変化を表し、アプリはそれらのEventを逐次適用してAggregateの状態を再現する
  - ドメインオブジェクトの履歴を保存でき、正確な監査ログの残すことができる
- 「スナップショット」を使って、再生しなければならないEventの数を減らし、パフォーマンスを向上させることができる
- イベントストア
  - DBとメッセージブローカーの両方の役割を持つEventの保存場所
  - サービスがEventをイベントストアに保存すると、イベントストアはEventをストレージに保存しつつPublishする
  - イベントストアの実装方法はいくつか候補があるが、本書では筆者が開発したOSSの「Eventuate」を使った方法紹介している
- Eventの変更・進化への対応はEvent sourcingの大きな課題の1つ
  - アップキャストという方法をつかうとうまく解決できる
- Event sourcingアプリはデータの削除に苦労する
- Event sourcingはSagaの実装がやりやすい。全面的にイベントストアを活用するかたちでアプリを開発することは十分可能

## Chapter7

「マイクロサービスアーキテクチャでのクエリ実装」

- クエリーで複数のサービスに分散されているデータを集める方法を説明
- `API composition`パターン もしくは `CQRS`パターンを使う

## Chapter8

- 様々な外部クライアント(モバイルアプリやJS、サードパーティ等)からのリクエストを処理する外部APIパターンについての説明

## Chapter9

- マイクロサービスの自動テストに関するテクニックの話、その1
- テストピラミッドについてと、テストピラミッドの底辺に位置するユニットテストの書き方の説明

## Chapter10

- マイクロサービスの自動テストに関するテクニックの話、その2
- ユニットテスト以外の書き方の説明
  - 統合テスト
  - コンシューマ駆動契約テスト
  - コンポーネントテスト

## Chapter11

- 本番環境でマイクロサービスにする際のTIPS
  - セキュリティ
  - `Externalized configuration`パターン
  - 可観測性パターン(`Log aggregation`、`Application metrics`、`Distributed tracing`)

## Chapter12

- サービスのデプロイで使える様々なパターンの説明
  - 仮想マシン、コンテナ、サーバレス等
- サービスメッシュを使うことのメリット

## Chapter13

- モノリシックなアプリを段階的にマイクロサービスにリファクタリングしていく方法の説明
- `Strangler application`パターン

