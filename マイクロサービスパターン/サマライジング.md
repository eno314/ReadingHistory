# マイクロサービスパターン サマライジング

## 装丁読み

- 英題 : Microservices Patterns With examples in Java
- マイクロサービスのパターン
- 実践的なシステムのデザイン
- コード解説
- 解説が充実している
  - パターンによるシステム開発
  - 実装方法をJavaのサンプルコードで
- マイクロサービスの事案を成功させる
- 実践的ノウハウを集めている
- Chris Richardson
  - <https://twitter.com/crichardson>
  - <https://www.chrisrichardson.net/>
  - マイクロサービスのトレーニングとコンサルティングをやっている
  - [POJOs in Action](https://www.amazon.co.jp/Pojos-Action-Developing-Applications-Lightweight/dp/1932394583)という本も出している（日本語訳は無さそう）
    - SpringやHibernateなどのFWを使ってJavaEEのアプリを構築する方法を説明する本
  - [Microservices.io](https://microservices.io/)の作者

## はじめに

本書はマイクロサービス宣言ではなく、パターンのコレクションを中心として構成されている

パターン : 特定のコンテキストで発生する問題に対して繰り返し応用できるソリューション
パターンの良いところ : ソリューションの利点だけでなく欠点や問題点も明示されている
↓
パターンを知っていれば、より良い決定をすることができるようになる

## 監修者まえがき

マイクロサービスのゴールは「素早く、高頻度に、アプリを開発・リリース・メンテナンスすること」

サービスのサイズが小さくなるのはあくまで結果であり、ゴールじゃない。だから小さくすることを目的にしたり、格好から入るようなことは良くないよ。

本書は設計のノウハウを単純にリストアップしているわけではなく、レガシーなアプリをモダン化していくストーリーになっていて、その中でマイクロサービスに関する様々な知識を解説している。つまり、マイクロサービスの適用を疑似体験できる作りになっている。

## 本書について

本書の目的 : マイクロサービスアーキテクチャを使ったアプリケーション開発を成功させるための方法を学ぶ

マイクロサービスのメリットだけでなくデメリットも挙げ、どんなときにモノリシックにして、どんなときにマイクロサービスにするのかを学ぶことができる

## Chapter1

「モノリシック地獄からの脱出」

- モノリシックなアプリケーションがヤバくなる兆候と、マイクロサービスを取り入れてそこから抜け出す方法
  - モノリシックアーキテクチャ : アプリを単一のデプロイ単位として構成。単純なアプリ向け。
  - マイクロサービスアーキテクチャ : システムを個別にデプロイでき、専用のDBを持つサービスに分割する。大規模で複雑なアプリ向け。
- マイクロサービスアーキテクチャの基本的な特徴と、メリット・デメリット
  - 特徴 : システムを個別にデプロイでき、専用のDBを持つサービスに分割する。
  - 大規模で複雑なアプリの場合にメリットが多い。
  - 万能薬ではない。大きな欠点がいくつもある（適切な分割が難しい、複雑になる、等）
- システムをマイクロサービスアーキテクチャにするだけでは上手く行かない
  - 「マイクロサービス」+「DevOps」+「小規模で自主性・自律性を持つチーム」が組み合わさることで、同時並行で仕事を進められ、ソフトウェア開発・デリバリーが加速する
  - 人間の問題（感情）を考慮する必要もある
- マイクロサービスアーキテクチャのパターン言語と、それを使うべき理由
  - パターン言語 : マイクロサービスを設計・開発する際に役立つパターン集
  - 使うべき理由 : マイクロサービスを取り入れるかの判断や、採用した際の効果的な適用方法を判断するのに役立つ

## Chapter2

「サービスへの分割」

- ソフトウェアアーキテクチャが重要な理由
  - アプリのメンテナンス性、テスト容易性、デプロイ容易性、等の開発スピードに影響を与える
  - マイクロサービスは、メンテナンス性、テスト容易性、デプロイ容易性を高めてくれる
- アプリケーションをサービスに分解するためのパターンを紹介
  - 技術的な問題ではなく、ビジネス上の問題(業務やサブドメイン)に基づいて構成する。
  - `Decompose by business capability` : 業務に対応させてサービスを定義するパターン
  - `Decompose by subdomain` : DDDのサブドメインに対応するかたちでサービスを定義するパターン
- サービスに分解する過程でぶつかる障害を乗り越える方法
  - 障害 : 神クラス(込み入った依存関係を作り出していて分割しにくいクラス)
  - 方法 : DDDの境界づけられたコンテキストの概念を使って、データを解きほぐし、分割を容易にする。サービスごとに別々のドメインモデルを定義する。

## Chapter3

「マイクロサービスアーキテクチャで使われるプロセス間通信」

- マイクロサービスは分散型のアーキテクチャなので、プロセス間通信が大きな役割を果たす
- サービスのAPIの発展の管理が大切
  - 下位互換のある変更は簡単
  - そうじゃない場合はすべてのクライアントがアップグレードされるまで、新旧両方のバージョンをサポートする必要がある
- プロセス間通信は色んなパターンがあるが、`Remote procedure invocation`と`Asynchronous messaging`のどちらにするかは特に重要な選択基準
- `Remote procedure invocation` : クライアントがRESTのような同期的なプロトコルを使ってサービスを起動する
  - `Circuit breaker`を使って、一部のサービスが落ちていても、全体に波及しないような工夫が必要
  - クライドベースのマイクロサービスでは、各サービスのネットワークは動的に割り当てれるので、サービスディスカバリのメカニズムを組み込む必要がある
    - たいていはクライドのプラットフォームがそういう機能を用意してくれている。無い場合はこの章で紹介されているパターンを参考にする。
- `Asynchronous messaging` : クライアントが非同期メッセージングを使ってサービスを呼び出す
  - 可用性を高くできる
  - メッセージシステムの細部を抽象化するような設計にする
  - DBの更新とメッセージのPublishをAtomicにする（どちらか片方だけ実行されて矛盾がおきないようにする）のは、非同期メッセージングの1つの大きな課題
  - `Transactional outbox`は優れた解決方法のひとつ
    1. DBトランザクションの一部として、DBにまずメッセージを書き出す
    1. `Transaction log tailing` か `Polling publisher` を使って、DBからメッセージを読み取りPublishする

## Chapter4

「サーガによるトランザクションの管理」

- マイクロサービスにおいて、複数のサービスに分散されたデータのトランザクション管理は難しい。
- XA/2PCベースの分散トランザクションは最近のストレージやメッセージの仕組みでは使えないため、Sagaパターンを使う方が良いことが多い。
- `Saga`
  - 非同期メッセージでコーディネートされた一連のローカルトランザクションを使って、複数にサービスにまたがるデータ整合性を維持する
  - Sagaのコーディネート方法は「コレオグラフィ」と「オーケストレーション」の2つ
  - 単純なサーガ以外はオーケストレーションを使うのがオススメ
- コレオグラフィ
  - 概要 : Sagaの参加サービスに次のステップの判断を委ねる
  - メリット : 単純で疎結合
  - デメリット : 分かりにくい、サービス間の循環的な依存が起きやすい、特定のサービス間の密結合の危険もある
- オーケストレーション
  - 概要 : コーディネートロジックを一元管理して、Saga参加サービスにどの操作を実行するか指示するコマンドを送る
  - メリット : 依存関係が単純、各サービス間が疎結合、関心事の分離がしやすくビジネスロジックも単純化されやすい
  - デメリット : オーケストレータにビジネスロジックが過度に集中するリスク
- SagaはACIDトランザクションとは異なり、I（分離性）が無いので、平行実行されるビジネスロジックの設計が難しい
  - 対策
    - 影響を最初化するカウンターメジャーを使う
    - ロックを使う（デッドロックのリスクはある）

## Chapter5

「マイクロサービスアーキテクチャにおけるビジネスロジックの設計」

- マイクロサービスにおけるビジネスロジックの実装パターン
  - `Transaction script` : 単純なビジネスロジックに適している。手続き型。
  - `Domain model` : 複雑なビジネスロジックに適している。オブジェクト指向型。
- 複雑なビジネスロジックの場合は、複数のDDDの`Aggregate`で構成することを推奨
  - 特徴
    - ドメインモデルのモジュール化
    - サービス境界を超えたオブジェクト参照の禁止
    - 個々のACIDトランザクションをひとつのサービス内で完結
  - Aggregateが作成・更新されたときは、`Domain event`をPublishするようにする
    - このイベントは様々な用途に使われる(Sagaを実装、複製されたデータ更新、ユーザーや他のアプリに通知、等)

## Chapter6

「イベントソーシングを使ったビジネスロジックの開発」

- `Event sourcing`
  - 個々のEventはAggregateの作成か状態変化を表し、アプリはそれらのEventを逐次適用してAggregateの状態を再現する
  - ドメインオブジェクトの履歴を保存でき、正確な監査ログの残すことができる
- 「スナップショット」を使って、再生しなければならないEventの数を減らし、パフォーマンスを向上させることができる
- イベントストア
  - DBとメッセージブローカーの両方の役割を持つEventの保存場所
  - サービスがEventをイベントストアに保存すると、イベントストアはEventをストレージに保存しつつPublishする
  - イベントストアの実装方法はいくつか候補があるが、本書では筆者が開発したOSSの「Eventuate」を使った方法紹介している
- Eventの変更・進化への対応はEvent sourcingの大きな課題の1つ
  - アップキャストという方法をつかうとうまく解決できる
- Event sourcingアプリはデータの削除に苦労する
- Event sourcingはSagaの実装がやりやすい。全面的にイベントストアを活用するかたちでアプリを開発することは十分可能

## Chapter7

「マイクロサービスアーキテクチャでのクエリ実装」

- マイクロサービスでは複数のサービスからデータを検索するクエリを書くのが難しい
  - 理由 : データはサービス毎にプライベートに扱われているため
  - 解決策 : `API composition` もしくは `CQRS` のパターンを使う
- `API composition`
  - 複数のサービスからデータを集めてくる
  - CQRSよりは簡単なので、できる限りこちらを使ったほうがいい
  - 複雑だったり大規模なクエリを実装しようする場合は、非効率な処理になってしまう
- `CQRS`
  - Command query responsibility segregation (コマンドとクエリの責任を分割する)
  - ビューデータベースをつかってクエリを実装する
  - 効率が良く強力だが、実装も複雑

## Chapter8

「外部APIパターン」

- 外部クライアント(モバイルアプリやJS、サードパーティ等)は、`API gateway`を介してアプリのサービスにアクセスするようにする
- `API gateway`
  - 個々のクライアントにカスタムAPIを提供する
  - リクエストのルーティング、API合成、プロトコル変換、認証、といったエッジ機能を実装する
- `Backends for frontends`
  - クライアントの種類毎にAPIゲートウェイを用意する
  - クライアントチームにBFFの開発・デプロイ・運用を任せて、クライアントチームが自主性・自律性を発揮できるようにする
- APIゲートウェイの設計・実装
  - 既製のAPIゲートウェイ製品もあれば、フレームワークを使って独自APIゲートウェイを開発する方法もある
  - フレームワークには、「Spring Cloud Gateway」や「GraphQL」がオススメ

## Chapter9

「マイクロサービスのテスト (前編)」

- マイクロサービスのメリットを最大限引き出すためには、テストの自動化が欠かせない
  - 理由
    - マイクロサービスは本質的に複雑
    - 自動テストはソフトウェアのスピーディで安全なデリバリの重要な基礎
- テストの目的 : 「SUTの振る舞いをチェックすること」
  - SUT : テスト対象のソフトウェア要素 (クラス1つ1つからアプリ全体のようなものまで、さまざまなものを指す)
- テストダブルを使って、テストを単純で高速実行できるようにする
  - テストダブルは大きく、スタブとモックの2種類に分けられる
  - スタブ : SUTに値を返すテストダブル
  - モック : SUTが依存サービスを正しく呼び出していることをチェックするテストダブル
- テスト戦略は、テストピラミッドに沿って立てる
  - テストの大部分はユニットテストにすべき
  - E2Eテストは最小限に抑える
- この章では、サービス内のクラスのユニットテストのサンプルコードを豊富に揃えている
  - エンティティ、値オブジェクト、サーガ、ドメインサービス、コントローラ、イベント/メッセージハンドラ

## Chapter10

「マイクロサービスのテスト (後編)」

- ユニットテスト以外の各テスト(統合テスト・コンポーネントテスト・E2Eテスト)の説明やサンプルコードが書いてある章
- サービス間連携のテストでは、「契約」と呼ばれるメッセージのサンプルを使ってテストする
  - Bad  : サービスと依存サービスの両方を実際に動かして行うテスト (テストに時間が掛かる)
  - Good : 両サービスのアダプタが契約に準拠していることをチェックするテスト
- コンポーネントテスト
  - APIを使ってサービスのふるまいや動作をチェックする
  - 他のサービスから分離しするために、依存サービスはスタブに置き換えて、単一のサービスとしてのテストにする
  - サービスの受け入れテストとしては、E2Eテストではなく、コンポーネントテストのほうが良い
- E2Eテスト
  - 前提 : テストの数は最小限にする
  - ユーザージャーニーテストを使う
    - ユーザーがアプリを使う流れをシュミレートして、アプリが提供する機能の大枠のふるまいチェックをするテスト

## Chapter11

「本番環境に耐えられるサービスの開発」

- 本番環境に耐えうるサービスにするには、機能要件だけでなく、「セキュア」「設定可能」「可観測性」が必要
- マイクロサービスのセキュリティは基本的にはモノリシックの場合と同じだけど、APIゲートウェイとサービスの間での認証・認可が別途必要になる
  - よく使われる方法 : APIゲートウェイがクライアントを認証する
- サービスは、環境(dev,test,stg,prod等)毎に外部サービスのネットワーク位置や認証情報を変える必要がある
  - `Externalized configuration` を使って実行時にサービスに設定情報を提供する
    - サービスのインスタンスを作る際にOSの環境変数や設定ファイルを参照して、環境ごとの情報を提供する
    - サービスのインスタンスが設定サーバーから設定情報を読み取る
- 可観測性パターンの実装は、運用部門と開発分門が仕事を分担する
  - 運用 : 可観測性インフラストラクチャ(ログ収集、メトリクス、例外トラッキング、分散トレーシングを処理するサーバーなど)を担当
  - 開発 : 自分たちが作るサービスに可観測性を持たせる
  - 可観測性パターン一覧
    - `Health check API` : サービスのヘルスチェックのためのエンドポイントを公開する
    - `Log aggregation` : サービスのアクティビティを中央のロギングサーバーに記録し、ロギングサーバーは検索とアラートの機能を備える
    - `Distributed tracing` : 個々の外部リクエストに一意なIDを与えて、サービス間のリクエストの流れをトレーシングする
    - `Exception tracking` : 例外トラッキングサービスに例外を報告し、例外トラッキングサービスは例外の重複排除・開発者へのアラート・解決までのトラッキングをする
    - `Application metrics` : サービスがメトリクスを管理し、メトリクスサービスがそれを収集できるようにする
    - `Audit logging` : ユーザーの動きをロギングする
- デプロイの単純化・加速のために、`Microservice chassis` を基礎としてサービス開発すべき
  - `Microservice chassis` : この章の内容を実現するためのフレームワーク、またはフレームワーク集
  - 今後は、ネットワーク関連の機能の多くは`Service mesh`に移っていく
  - `Service mesh` : サービスを出入りするすべてのネットワークフローが、あるネットワーク階層を通過するようにして、そこで横断的な関心事を実装する

## Chapter12

「マイクロサービスのデプロイ」

- サービスの要件をサポートするデプロイメントパターンのなかで、もっとも軽量なものを選ぶようにする
- `Serverless deployment`
  - 第一の選択肢
  - AWS LambdaやGoogle Cloud FUnctions、Azure Functions等。
  - レイテンシが大きくなることがあったり、イベント/リクエストベースのプログラミングモデルに制限されたりと、すべてのサービスに使えるわけではない
  - 上記が問題ないサービスであれば積極的に使うべき
- `Service as a container`
  - サーバレスに適していない場合の、第二の選択肢
  - サーバレスよりも多くのプログラミングモデルで使え、レイテンシも予測可能
  - KubernetesなどのDockerオーケストレーションフレームワークを使うと効果的
  - デメリット : OSやランタイム、Dockerオーケストレーションフレームワーク、コンテナ下のVMの保守管理が必要
- `Service as a VM`
  - コンテナが適していない場合の第三の選択肢
  - AWSのEC2等では高度に自動化がされていて、豊富な機能も提供されてるので、小規模で単純なアプリのデプロイであればコンテナよりも簡単にサービスが作れる場合がある
- `Language-specific packaging format`
  - 本番環境に言語固有パッケージをデプロイするパターンで、最も重く、なるべく避けるべき
- サービスメッシュを使うことで、デプロイとリリースの分離が実現できる
  - サービスを本番環境にデプロイし、本番環境でテストしてから、本番トラフィックに新サービスをルーティングする

## Chapter13

「マイクロサービスのリファクタリング」

- モノリシックをマイクロサービスに移行すべきタイミング
  - アプリがモノリシックの枠に収まりきれなくなったために、デリバリが遅くなっていることが確認できたら
  - モノリシックでも開発スピードが下がっていないなら、まだマイクロサービスに変える必要はない
- モノリシックをマイクロサービスにリファクタリングする際は、段階的に長期的なスパンでやっていくのが良い
- リファクタリングの戦略は、`Strangler application` を使うのが良い
  - 古いアプリ(モノリス)を包囲するように、新しいアプリ(サービス)を段階的に開発していく
  - モノリスを時間とともに縮小させる
- 新機能をサービスとして実装するのは、マイクロサービスを適用する第一歩としていい方法
  - 最新のテクノロジスタックと開発プロセスを使って、機能を短期間かつ用意に実装できる
  - マイクロサービスへの移行のメリットを、ステークホルダーに伝えやすい
- モノリスの分解方法1 : BEからプレゼンテーションを分解して、2つの小さなモノリスを作る
  - 大幅な改善にはならないが、それぞれを個別に開発・デプロイできるようになる
- モノリスの分解方法2 : 機能をモノリスからサービスに段階的に移していく
  - 活発に開発されている機能を抽出してサービス化することで、開発の加速につながることができる
- モノリスを分解する際のテクニック
  - インテグレーショングルー
    - サービスとモノリスの連携を実現するためのもの(RESTやメッセージでやり取りする処理)
    - モノリスのドメインモデルがサービスのドメインモデルを汚染することを防ぐために、腐敗防止層を使うようにする
  - サービスに移管したデータはモノリスのDBにレプリケートする（モノリスの修正を最小限にすることができる）
  - サービスとモノリスを巻き込んだサーガ（トランザクション）は大変なので、サービスの移行順序を慎重に検討する
  - セキュリティもモノリス用とサービス用の両方をサポートする必要がある


