# 達人プログラマー 第2版 サマライジング

## 装丁読み

- 達人
- プログラマー
- 熟達に向けた
- あなたの旅
- The Pragmatic(現実的？) Programmer
- your journey to mastery
- 20th anniversary edition
- David Thomas
  - <https://en.wikipedia.org/wiki/Dave_Thomas_(programmer>)
- Andrew Hunt
  - <https://en.wikipedia.org/wiki/Andy_Hunt_(author>)

## 序文

- 第1版はプログラミング力を強化するための具体的な例やアイディア、実践的なTIPSが詰まった本
- 第2版はさらに2つの強化点がある
  - 時代に合わなくなった参照や例を削除して、現代的な内容に置き換えている
  - 第1版の読者からのフィードバックを得て、ブラッシュアップしている
- 主体性が重要。開発者は他のプロフェッショナルよりも主体性が必要。
- 本書はより良いプログラマーになるためのガイド
  - 達人プログラマーとはどういった人であるかを教えてくれる
- 達人プログラマーになりたいかどうかは、読者自身の決断に委ねられている

## まえがき

- 本書のほぼ1/3は全く新しい書き下ろし、残りの大半も部分的に書き直したり、新たに書き起こしたりしている
- この本の構成
  - 短いセクションの集まり。各セクションは特定の話題に特化して、それぞれで完結している。
  - 多くのクロスリファレンスによって、それぞれの話題の理解も深められる
  - どの順で読んでも構わない
  - 「Tip 〇〇」という見出しのついた箱書きは、本書において強調すべき重要な点であり、生きた言葉。巻末に一覧で見ることができる

## 第1版のまえがきる
- 日本語(自分の母国語)をもうひとつのプログラミング言語として考え、伝達しやすくる
  - DRY原則やETC(変更しやすくする)、自動化などを守る

## 第2章 達人のアプローチ

- よい設計の本質 : 「ETC(Easier To Change)原則」
  - すべての設計原則は、ETC原則を特殊化したもの
  - どういった形に変更するか分からない場合、常に「簡単に変更できる」という選択肢を採用するようにする
  - 変更しやすくする設計ができる能力を養うようにする(エンジニアリング日誌で選択したことをメモする等)
- 可逆性 : 柔軟で適合性の高いソフトウェアをつくる(本書の話題のほとんど)
  - 特に「DRY原則」「分離」「外部設定の使用」を貫き通せば、後戻りが許されない多くの重大な意思決定から解法される
  - コードだけでなく、アーキテクチャやデプロイ、ベンダー統合という切り口からも柔軟性を維持する
- DRY原則はコード以外にも適用される
  - コメントがコードと同じことを示しているのはDRY原則違反
  - プロジェクト内のさまざまな開発者間で発生する重複がもっとも検出と取り扱いが難しい。チームビルディングが重要。
- 設計に直行性があるかどうか確認するには、あるコンポーネントを大幅に変更しないといけなくなった場合に、影響箇所が1つのコンポーネントだけになっていればいい
- 直行性はコードだけでなくドキュメントにも適用できる(テキストを変更することなく、見た目を変えることができる)
- 曳光弾 : 最初から全体を見渡せるように作る。プロトタイプとは違って使い捨てはしない。
- プロトタイプの価値は、生成されたコードではなく、学んだ教訓(学習の経験)にある。
- 専門の用語
  - 問題領域に近いところでプログラミングするっていうのがピンとこない。DDDなのかなと思ったけど、DSLの話っぽくて、具体的にどうすれば良いのか落とし込めない。。
- 見積もりは１つだけでなく、楽観的・現実的・悲観的の3つを考える

## 第3章 基本的なツール

- プレインテキストは人間が直接読んで理解できるフォーマットで、知識を永続的に格納するのに最も適している
- エンジニア日誌はメリットが多い。手書きでやるのがおすすめ。

## 第4章 妄想の達人

- 完璧なソフトウェアを作ることはできない
  - 自分を含めて誰もが完璧なコーディングができないという事実を知ることで、達人プログラマーのコードは、彼ら自身の過ちに対して防衛的になる
- 契約による設計(DbC)
  - 機能を供給する側と使う側が、権利と責任について合議しておく必要がある
  - 要求された以上のことも、以下にのことも行わないようにプログラムを書く
- 死んだプログラムは嘘をつかない
  - バグ探しの作業の足を引っ張らないように、プログラムの状態をこまめにチェックし、おかしな状態になる前に停止させる
  - 「あり得ない」と思われる事象がコードの実行中に発生した場合、その時点でプログラムは実行可能なものとはなっていない
  - 停止したプログラムのほうが、障害によって中途半端に動作しているプログラムよりもダメージは少ない
- 表明を用いたプログラミング
  - 簡潔な検証方法、積極的に自分の仮設を検証してくれるコードの記述方法の解説
  - 起こり得ないとうのであれば、表明を用いてそれを保証する(チェックする)コードを追加する
  - 本番環境でも基本的に表明はオフにしない。もしパフォーマンスに影響があるのなら、その部分だけをオフにする
- リソースのバランス方法
  - システムリソースのやりくりに失敗しないとめのヒント
  - 「始めたことは終わらせる」「ものごとを局所的にする」
- ヘッドライトを追い越そうとしない
  - 常に小さい歩幅で少しずつ前に進むように意識し、フィードバックを得た上で、先に進む前に軌道修正を加える
  - 予言になるような遠く先のことを見通そうとはせずに、予測できる小さな歩幅・タスクにする

## 第5章 柳に雪折れ無し

- どうすれば可逆的な意思決定が行えるのかについて解説した章
- 分離
  - コード自らが直接知っていることのみを実行するようにするが、分離に繋がり、変更に強いものになる (具体的な手段は以下)
  - TDA(Tel, Don't Ask)、照会せずに依頼する
  - メソッド呼び出しを連鎖させない (ドットを2つ以上続けてはいけない)、ただし、変更される可能性がない場合は除く(言語に付随するライブラリ等)
  - 大域データを避ける、変数だけでなく、Singletonや外部リソースも大域データ。外部リソースはラップして隠蔽して使う。
- 実世界を扱う
  - イベントに応答するアプリが作れるのであれば、それは現実世界で適切に動作するアプリになる
  - イベントを中心にしたコードは、直列的に処理していくコードよりもレスポンシブで、より分離したものになる
- 変換のプログラミング
  - あらゆるプログラムはデータを変換し、入力を出力に変える -> プログラミングはコードについての話であるが、プログラムはデータについての話
  - 状態を溜め込まずに、引き渡すようにする
  - コードを(ネストした)変換の連続と捉える
- インヘリタンス(相続)税
  - インヘリタンスを使わず、`インタフェースとプロトコル`、`委譲`、`mixinとtrait`を使う
  - ポリモーフィズムはインタフェースで表現する
  - `is - a` よりも `has - a`
  - 機能の共有には `mixin` を使用する
- 設定
  - 外部設定を用いて、アプリをパラメータに対応させておけば、本番稼働に入った後でも簡単に変更できる
  - 変更する必要があると分かっているものは、何でもコードの外側に出して、設定データとして扱う
  - 設定情報はAPIの裏側に隠して、詳細である設定の表現方法を、コードから分離する
  - サービスとしての設定(Configuration-as-a-Service)として、サービスAPIの背後に保持するのも、メリットが多くてあり

## 第6章 並行性

- 並行処理 : 複数のコードがあたかも同時に実行されているように振る舞うこと。
- 並列処理 : 複数のコードが本当に同時に実行されることで、複数の物事を同時に実行できるハードウェアが必要。
- 並行処理は、ものごとが非同期に発生する現実世界とやり取りする場合には必須(全部順々に処理すると、システムは重くなり、ハードウェアの力をフルに発揮できない)
- 時間的な結合を破壊する
  - 設計を考えたりプログラムを書く際は、並行性を考慮して、時間や順序からの分離を考えたほうが、システム全体の柔軟性が増し、結果、より迅速で信頼性に優れた、予測しやすいシステムになる
  - 並行部分を探すには、アクティビティ図を使って、ワークフローを分析すると良い
- 共有状態は間違った状態
  - 共有メモリだけでなく、変更可能なリソースを共有している場所で、並行処理の問題は発生する可能性がある
- アクターとプロセス
  - 共有状態を持たないアクターを並行処理で使用する
- ホワイトボード
  - ホワイトボードのメタファー : 上部に達成したい目標を書き、その下部に色んな人がそれぞれ得た情報を書き込む。それが貯まることで目標が達成される。
  - システムも同様にすることで複雑なものも扱えるようになることがある
  - マイクロサービスでメッセージシステムを構築する場合も、ホワイトボードシステムと言える
  - それぞれのアプリの配備や管理が大変になる一方で、システムの粒度を細かくできるので細かくアップデートすることが可能になる

## 第7章 コーディング段階

- プログラムを長期間にわたって正確かつ生産的なものに保つには、熟考や熟慮を要する意思決定が常に必要
  - コーディングは機械的な作業ではない
  - 常に状況を再検討し、問題の可能性をチェックし、不備の事態に備える
- 爬虫類からの声に耳を傾ける
  - プログラマーとして経験を積んでいくとともに、自分の脳には暗黙知が蓄積されている
  - ある作業を前にして、何か疑いが感じられたり気が進まない場合は、過去の経験が何かを伝えようとしているのかもしれないで、その忠告に耳を傾ける
  - 本能に耳を傾けながらコーディングすることができるようになると、より大きなスケール(設計や要件定義の際)にも応用が効く
- 偶発的プログラミング
  - 「偶発的プログラミング(運・いきあたりばったり)」ではなく、「慎重なプログラミング」を選ぶ
  - 慎重なプログラミングの方法
    - 常に何をやっているのかを意識する
    - 信頼の置けるものだけを前提とする
    - 仮定して使わなければならないのなら、ドキュメント化とテストは必須
- アルゴリズムのスピード
  - 高速のCPUの動きを止めてしまいかねないアルゴリズムを作ってしまうこともある
  - アルゴリズムのスピードは、オーダーを使って見積もり、検証する
  - アルゴリズムを改良するのは、それが本当にボトルネックになってから行うべき
- リファクタリング
  - 達人プログラマーは、プログラムや設計に改善の余地がないかを常に見定めている
  - ソフトウェア開発は、建築というよりもガーデニングに近い(コンクリートよりも有機的なも)
  - 大きな問題にならないうちに、早めに、こまめにリファクタリングする。今が一番痛みが少なくリファクタリングすることができるタイミング。
- コードのためのテスト
  - テストの主な利点は、テストを実行しているとき(バグを見つけること)ではなく、テストについて考え、テストを作り出している時に生み出される
  - テストが開発時のちからになることは間違いないが、目的地が明確になっていることが前提(これができていないと、どんな方法論であってもうまくいかない)
  - テストはプログラミングの一部。テスト・設計・コーディング、これらはすべてプログラミング
- プログラミングは、トップダウンでもボトムアップでもなく、エンドツーエンドで行うべき
- プロパティベースのテスト
  - 契約と不変性を検証するためのテストで、同じテストをデータをランダムに変えて複数回に実行させる
  - 自分に代わってコンピュータに幅広いテストを実施させる
  - 「変更してはいけないものは何か」「本当のものは何か」ということを考えさせてくれる
- 実世界の外敵から身を守る
  - 現実の世界は厳しく、システムに侵入して害をなそうとあの手この手を画策する悪人で満ちあふれている
  - 基本原則
    - KISSを守って、アタックサーフェスを最小化する
    - デフォルトをセキュアにしておく
    - 機密データは暗号化する
    - セキュアアップデートをすぐに適用する
  - 暗号化機能は自作せずに信頼の置けるものを使い、自身のアプリやサイトで使っているセキュリティ技術にも厳しい目を向けながら実装する
- ものの名前
  - ソフトウェア開発で最も難しいことの１つが、「ものの名前」
  - 自分たちはさまざまなものに名前をつけることになるが、それによって作り出すもののかたちも定義されることになる
  - コーディング中には、意味が変質していく可能性についても意識していく必要がある
  - なにかに名前を付ける場合は、常に、自らの意図を明確にする方法を探す。(それが、自分が書いているコードへの理解も深くなる)
  - コード内に付けた名前に一貫性を持たせる。チーム内のコミュニケーションはその単語を使って会話したり、用語集を用意するのもあり
  - 名前に問題を見つけたのであれば、すぐにその場で修正する。

## 第8章 プロジェクトを始める前に

- プロジェクトを立ち上げる「前」に、以下の重要な課題を片付けておけば、プロジェクトの成功・完了に向けて優位に立てる
- 要求の落とし穴
  - やることを告げられる、あるいはユーザーの言うことに耳を傾けるだけでは不十分
    - 理由 : 自分が欲しているものを正確に認識している人などいないから
    - プログラマの仕事 : 人々自身が欲しているものを自らで気づいてもらえるように支援すること。
    - 自分たちにソフトウェア開発を依頼してくるクライアントは、相談者
  - 要求は、クライアントと一緒にフィードバックループを繰り返しながら学んでいくもの
    - あらゆるプロジェクトは、要求収集のための修業の場
    - クライアントとの気持ちを理解するには、クライアントと一緒に働く、実際に経験してみるのが良い
  - 業務のポリシーは、要求とは分けて見極め、業務のポリシーであるならメタデータとして扱い、変更しやすいようにしておく
  - 要求文書
    - 最良の要求文書は「実行可能なコード」
    - 要求文書はクライアントのためではなく、計画(チームの開発者に何を実行すべきか認識してもらうためのもの)
    - 要求とは「ニーズ」なので、要求文書は、詳細にも踏み込んで正確・完結にニーズを反映しているもの
  - プロジェクトの用語集を作ったほうが良い
- 不可能なパズルを解決する
  - 難しい問題は、どの工程でも突発的に発生するものだが、落ち着いて対処すれば、たいていは最初に感じたほど難しいものではないはず
  - 不可能に思えるような難しい問題の対処法
    - 制約を見直して考えてみる。枠にとらわれずに考えるのではなく、本当の枠(制約)が何なのかを見つけ出す。
    - しばらく他のことをやってみるのも有効。人間の脳は、他の作業に気を取られている間も、意識していないところで問題に対して考え続けている
- 共に働く
  - 不可能とも思えるプロジェクトに遭遇したときの伝家の宝刀
  - 実際にコードを開発している最中に、質問したり議論をする(ペアプロ・モブプロ)
  - ユーザーもチームの一員として緊密に働く。コンウェイの法則からも、ユーザーと一緒のチームのほうが、ユーザーの意図を反映できるもの作ることができる
  - 一人ぼっちでコーディングに取り組むのだけは避ける
- アジリティーの本質
  - どれだけアジャイルのプロセスやツールを周到に用意としても、「考える」手法を置き換えることはできない
  - これをやったらアジャイルで、全てが上手くいくようなプラクティスなど存在しないが、アジャイルな方法で仕事するためのレシピならある
    1. 自らの現在地点を見つけ出す
    2. 目的地点に向けて、最も意味のある最小単位の一歩を踏み出す
    3. 現在地点を評価(振り返り)し、問題があれば修正する
  - アジャイルを機能させるには、変更しやすいことはとても重要になってくるので、優れた変更しやすい設計・コードが大事

## 第9章 達人のプロジェクト

- プロジェクトの成否を分けるいくつかの重要な領域についての解説
- 達人のチーム
  - 達人の哲学を守りながら、プロジェクト内の基本原則と役割分担を決める方法
- ココナツでは解決できない
  - ソフトウェア開発手法の目的 : 人々が一致協力して作業できるように支援する
  - ソフトウェア開発手法のメリットを最大限得ることができ、プロジェクトに成功をもたらす真の秘訣について
- 達人のスターターキット
  - 着実かつ信頼性あるかたちでソフトウェアを調達するための三種の神器 : バージョン管理・テスト・自動化
- ユーザーを喜ばせる
  - プロジェクトの最終的な成功はスポンサーからみた観点。スポンサーを喜ばせる方法についての考察
- 自負と偏見
  - 自らの成果に署名をし、実行したことに誇りを持つ

## あとがき

- プログラマーは世界を変える力を持っているだけに、大きな責任もついてまわる
- 「害をなさないようにすること」「極悪なことを実行できるようにしないこと」
  - 「私はユーザーを守っているか？」「自分でもこれを使用するきになるだろうか？」を開発するものごとに意識する
- プログラマーの職務 : すべての人が、そこで過ごしたいと思うような未来を作ること
- 「これはあなたの人生だ。皆と共有し、祝福し、生み出していくこと。そして思いっきり楽しむこと!」

## 訳者あとがき

- 本書は、第1版からパワーアップした内容になっている
  - 今では陳腐化してしまったテクノロジーの記述は削ぎ落としている
  - 20年間にわたるフィードバックを盛り込んでいる
  - 構成も新たな観点を加えた形で見直されている
  - TIPSの数も70から100に増えている

## TIPS

- テスト周りの内容が興味が湧いた。テストの章を重点的に読みたくなった。
  - 「テストはコードのユーザー第1号である」
  - 「トップダウンでもボトムアップでもなく、エンドツーエンドで構築していく」
  - 「テスト設計を行うこと」(コードの記述を始める前にテストのことを考え始める)
