# 達人プログラマー 第2版 サマライジング

## 装丁読み

- 達人
- プログラマー
- 熟達に向けた
- あなたの旅
- The Pragmatic(現実的？) Programmer
- your journey to mastery
- 20th anniversary edition
- David Thomas
  - <https://en.wikipedia.org/wiki/Dave_Thomas_(programmer>)
- Andrew Hunt
  - <https://en.wikipedia.org/wiki/Andy_Hunt_(author>)

## 序文

- 第1版はプログラミング力を強化するための具体的な例やアイディア、実践的なTIPSが詰まった本
- 第2版はさらに2つの強化点がある
  - 時代に合わなくなった参照や例を削除して、現代的な内容に置き換えている
  - 第1版の読者からのフィードバックを得て、ブラッシュアップしている
- 主体性が重要。開発者は他のプロフェッショナルよりも主体性が必要。
- 本書はより良いプログラマーになるためのガイド
  - 達人プログラマーとはどういった人であるかを教えてくれる
- 達人プログラマーになりたいかどうかは、読者自身の決断に委ねられている

## まえがき

- 本書のほぼ1/3は全く新しい書き下ろし、残りの大半も部分的に書き直したり、新たに書き起こしたりしている
- この本の構成
  - 短いセクションの集まり。各セクションは特定の話題に特化して、それぞれで完結している。
  - 多くのクロスリファレンスによって、それぞれの話題の理解も深められる
  - どの順で読んでも構わない
  - 「Tip 〇〇」という見出しのついた箱書きは、本書において強調すべき重要な点であり、生きた言葉。巻末に一覧で見ることができる

## 第1版のまえがきる
- 日本語(自分の母国語)をもうひとつのプログラミング言語として考え、伝達しやすくる
  - DRY原則やETC(変更しやすくする)、自動化などを守る

## 第2章 達人のアプローチ

- よい設計の本質 : 「ETC(Easier To Change)原則」
  - すべての設計原則は、ETC原則を特殊化したもの
  - どういった形に変更するか分からない場合、常に「簡単に変更できる」という選択肢を採用するようにする
  - 変更しやすくする設計ができる能力を養うようにする(エンジニアリング日誌で選択したことをメモする等)
- 可逆性 : 柔軟で適合性の高いソフトウェアをつくる(本書の話題のほとんど)
  - 特に「DRY原則」「分離」「外部設定の使用」を貫き通せば、後戻りが許されない多くの重大な意思決定から解法される
  - コードだけでなく、アーキテクチャやデプロイ、ベンダー統合という切り口からも柔軟性を維持する
- DRY原則はコード以外にも適用される
  - コメントがコードと同じことを示しているのはDRY原則違反
  - プロジェクト内のさまざまな開発者間で発生する重複がもっとも検出と取り扱いが難しい。チームビルディングが重要。
- 設計に直行性があるかどうか確認するには、あるコンポーネントを大幅に変更しないといけなくなった場合に、影響箇所が1つのコンポーネントだけになっていればいい
- 直行性はコードだけでなくドキュメントにも適用できる(テキストを変更することなく、見た目を変えることができる)
- 曳光弾 : 最初から全体を見渡せるように作る。プロトタイプとは違って使い捨てはしない。
- プロトタイプの価値は、生成されたコードではなく、学んだ教訓(学習の経験)にある。
- 専門の用語
  - 問題領域に近いところでプログラミングするっていうのがピンとこない。DDDなのかなと思ったけど、DSLの話っぽくて、具体的にどうすれば良いのか落とし込めない。。
- 見積もりは１つだけでなく、楽観的・現実的・悲観的の3つを考える

## 第3章 基本的なツール

- プレインテキストは人間が直接読んで理解できるフォーマットで、知識を永続的に格納するのに最も適している
- エンジニア日誌はメリットが多い。手書きでやるのがおすすめ。

## 第4章 妄想の達人

- 完璧なソフトウェアを作ることはできない
  - 自分を含めて誰もが完璧なコーディングができないという事実を知ることで、達人プログラマーのコードは、彼ら自身の過ちに対して防衛的になる
- 契約による設計(DbC)
  - 機能を供給する側と使う側が、権利と責任について合議しておく必要がある
  - 要求された以上のことも、以下にのことも行わないようにプログラムを書く
- 死んだプログラムは嘘をつかない
  - バグ探しの作業の足を引っ張らないように、プログラムの状態をこまめにチェックし、おかしな状態になる前に停止させる
  - 「あり得ない」と思われる事象がコードの実行中に発生した場合、その時点でプログラムは実行可能なものとはなっていない
  - 停止したプログラムのほうが、障害によって中途半端に動作しているプログラムよりもダメージは少ない
- 表明を用いたプログラミング
  - 簡潔な検証方法、積極的に自分の仮設を検証してくれるコードの記述方法の解説
  - 起こり得ないとうのであれば、表明を用いてそれを保証する(チェックする)コードを追加する
  - 本番環境でも基本的に表明はオフにしない。もしパフォーマンスに影響があるのなら、その部分だけをオフにする
- リソースのバランス方法
  - システムリソースのやりくりに失敗しないとめのヒント
  - 「始めたことは終わらせる」「ものごとを局所的にする」
- ヘッドライトを追い越そうとしない
  - 常に小さい歩幅で少しずつ前に進むように意識し、フィードバックを得た上で、先に進む前に軌道修正を加える
  - 予言になるような遠く先のことを見通そうとはせずに、予測できる小さな歩幅・タスクにする

## 第5章 柳に雪折れ無し

- どうすれば可逆的な意思決定が行えるのかについて解説した章
- 分離
  - コード自らが直接知っていることのみを実行するようにするが、分離に繋がり、変更に強いものになる (具体的な手段は以下)
  - TDA(Tel, Don't Ask)、照会せずに依頼する
  - メソッド呼び出しを連鎖させない (ドットを2つ以上続けてはいけない)、ただし、変更される可能性がない場合は除く(言語に付随するライブラリ等)
  - 大域データを避ける、変数だけでなく、Singletonや外部リソースも大域データ。外部リソースはラップして隠蔽して使う。
- 実世界を扱う
  - イベントに応答するアプリが作れるのであれば、それは現実世界で適切に動作するアプリになる
  - イベントを中心にしたコードは、直列的に処理していくコードよりもレスポンシブで、より分離したものになる
- 変換のプログラミング
  - あらゆるプログラムはデータを変換し、入力を出力に変える -> プログラミングはコードについての話であるが、プログラムはデータについての話
  - 状態を溜め込まずに、引き渡すようにする
  - コードを(ネストした)変換の連続と捉える
- インヘリタンス(相続)税
  - インヘリタンスを使わず、`インタフェースとプロトコル`、`委譲`、`mixinとtrait`を使う
  - ポリモーフィズムはインタフェースで表現する
  - `is - a` よりも `has - a`
  - 機能の共有には `mixin` を使用する
- 設定
  - 外部設定を用いて、アプリをパラメータに対応させておけば、本番稼働に入った後でも簡単に変更できる
  - 変更する必要があると分かっているものは、何でもコードの外側に出して、設定データとして扱う
  - 設定情報はAPIの裏側に隠して、詳細である設定の表現方法を、コードから分離する
  - サービスとしての設定(Configuration-as-a-Service)として、サービスAPIの背後に保持するのも、メリットが多くてあり

## 第6章 並行性

- 並行処理 : 複数のコードがあたかも同時に実行されているように振る舞うこと。
- 並列処理 : 複数のコードが本当に同時に実行されることで、複数の物事を同時に実行できるハードウェアが必要。
- 並行処理は、ものごとが非同期に発生する現実世界とやり取りする場合には必須(全部順々に処理すると、システムは重くなり、ハードウェアの力をフルに発揮できない)
- 時間的な結合を破壊する
  - 設計を考えたりプログラムを書く際は、並行性を考慮して、時間や順序からの分離を考えたほうが、システム全体の柔軟性が増し、結果、より迅速で信頼性に優れた、予測しやすいシステムになる
  - 並行部分を探すには、アクティビティ図を使って、ワークフローを分析すると良い
- 共有状態は間違った状態
  - 共有メモリだけでなく、変更可能なリソースを共有している場所で、並行処理の問題は発生する可能性がある
- アクターとプロセス
  - 共有状態を持たないアクターを並行処理で使用する
- ホワイトボード
  - ホワイトボードのメタファー : 上部に達成したい目標を書き、その下部に色んな人がそれぞれ得た情報を書き込む。それが貯まることで目標が達成される。
  - システムも同様にすることで複雑なものも扱えるようになることがある
  - マイクロサービスでメッセージシステムを構築する場合も、ホワイトボードシステムと言える
  - それぞれのアプリの配備や管理が大変になる一方で、システムの粒度を細かくできるので細かくアップデートすることが可能になる

## 第7章 コーディング段階

## 第8章 プロジェクトを始める前に

## 第9章 達人のプロジェクト

## あとがき

- プログラマーは世界を変える力を持っているだけに、大きな責任もついてまわる
- 「害をなさないようにすること」「極悪なことを実行できるようにしないこと」
  - 「私はユーザーを守っているか？」「自分でもこれを使用するきになるだろうか？」を開発するものごとに意識する
- プログラマーの職務 : すべての人が、そこで過ごしたいと思うような未来を作ること
- 「これはあなたの人生だ。皆と共有し、祝福し、生み出していくこと。そして思いっきり楽しむこと!」

## 訳者あとがき

- 本書は、第1版からパワーアップした内容になっている
  - 今では陳腐化してしまったテクノロジーの記述は削ぎ落としている
  - 20年間にわたるフィードバックを盛り込んでいる
  - 構成も新たな観点を加えた形で見直されている
  - TIPSの数も70から100に増えている

## TIPS

- テスト周りの内容が興味が湧いた。テストの章を重点的に読みたくなった。
  - 「テストはコードのユーザー第1号である」
  - 「トップダウンでもボトムアップでもなく、エンドツーエンドで構築していく」
  - 「テスト設計を行うこと」(コードの記述を始める前にテストのことを考え始める)
